# Progress Log

## Learnings
(Notes discovered during implementation)

### Pre-Implementation Research (2026-01-20)

**Gov.il Site Structure:**
- All three databases use AngularJS with client-side rendering
- Dynamic content loaded via `ng-controller="dynamicCtrl"`
- Pagination: `?skip=N` parameter (10 items per page)
- PDF URLs pattern: `https://free-justice.openapi.gov.il/...`
- Search autocomplete: `https://searchgov.gov.il/govil/Suggestext/`

**Existing Code Issues (from QA-FINDINGS.md):**
- 19 issues identified, 3 CRITICAL
- ALL CSS selectors are outdated
- Tool name mismatch: README says `search_land_decisions`, code has `search_decisions`
- Non-existent `search_and_read` tool documented but not implemented
- Angular wait timeout too short (2s fallback)
- No filter success verification

**Working Components:**
- SQLite database layer (`mcp-server/src/database.ts`) - GOOD
- Type definitions (`mcp-server/src/types.ts`) - GOOD
- Indexer logic (`mcp-server/src/indexer.ts`) - GOOD
- Basic MCP server structure (`mcp-server/src/index.ts`) - GOOD

**Broken Components:**
- Scraper selectors (`mcp-server/src/scraper.ts`) - BROKEN
- Puppeteer flow (`mcp-server-live/src/`) - BROKEN

**Key Design Decisions:**
1. Keep SQLite + FTS5 approach (proven to work)
2. Rebuild scraper with multiple fallback strategies
3. Add selector health check before full crawl
4. Improve tool descriptions with Hebrew examples
5. Add query clarification tool for ambiguous queries

---

## Iteration 1 — US-001 Task 1: ScraperAPI render/premium configuration
- **What was done**: Verified existing implementation in scraper.ts already uses `render=true` and `premium=true` as defaults
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 32-33 and 40-45)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Learnings for next cycles**:
  - Patterns: ScraperAPI URL built via `URLSearchParams` with api_key, url, render, premium params
  - Patterns: `buildScraperUrl()` method centralizes URL construction
  - Helpful context: The scraper defaults to premium=true and render=true via nullish coalescing (`??`)

---

## Iteration 2 — US-001 Task 2: Multiple selector strategies with fallbacks
- **What was done**: Implemented multi-strategy fallback system for resilient HTML parsing
- **Files affected**: `mcp-server/src/scraper.ts` (major refactor of parseDecisions method)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `SelectorStrategyType` type: 'css_primary' | 'css_structural' | 'regex_fallback'
  - Created `SelectorConfig` interface with configurable selectors for each strategy
  - Implemented `DEFAULT_SELECTORS` constant with:
    - Primary selectors: class-based (e.g., `.dynamic-card`, `.result-item`)
    - Structural selectors: tag/attribute-based (e.g., `div[ng-repeat]`, `article`)
    - Regex patterns: raw HTML extraction (e.g., `/הכרעת שמאי[^<\n]{10,200}/g`)
  - Strategy tracking: `lastStrategyUsed`, `strategyStats` map
  - Helper methods: `getLastStrategyUsed()`, `getStrategyStats()`, `logStrategy()`
  - Refactored `parseDecisions()` to call strategies in order and log warnings on fallback
- **Learnings for next cycles**:
  - Patterns: Cheerio CheerioAPI type for $ parameter in helper methods
  - Patterns: Use `cheerio.Cheerio<cheerio.Element>` for element wrappers
  - Traps: Regex patterns must be reset (use `g` flag) or create new instances per match
  - Traps: HTML capture groups need cleaning with `.replace(/<[^>]*>/g, '')`
  - Helpful context: Logging to stderr (not stdout) preserves MCP stdio protocol

---

## Iteration 4 — US-001 Task 4: Parse HTML with Cheerio using adaptive patterns
- **What was done**: Verified existing implementation of adaptive Cheerio parsing with three extraction strategies
- **Files affected**: `mcp-server/src/scraper.ts` (already implemented in iteration 2, marking as complete)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `parseWithCssPrimary()` (lines 299-350): Uses class-based selectors like `.dynamic-card`, `.result-item`
  - `parseWithCssStructural()` (lines 355-375): Uses tag/attribute-based selectors like `div[ng-repeat]`, `article`
  - `parseWithRegex()` (lines 380-442): Uses regex patterns for raw HTML extraction
  - `parseDecisions()` (lines 260-294): Orchestrates all three strategies with automatic fallback
  - Warning logs when primary selectors fail but fallback succeeds (line 275, 285)
- **Learnings for next cycles**:
  - Patterns: Code implemented in iteration 2 covered multiple acceptance criteria
  - Patterns: Check existing implementation before assuming work is needed
  - Helpful context: DEFAULT_SELECTORS constant (lines 79-160) contains all selector configurations

---

## Iteration 5 — US-001 Task 5: Extract title, PDF URL, block, plot, committee, appraiser, case type, dates
- **What was done**: Enhanced `parseTitleMetadata()` method with comprehensive extraction patterns for all three databases
- **Files affected**: `mcp-server/src/scraper.ts` (lines 501-650, major refactor of parseTitleMetadata)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Strategy 1: Full pattern for decisive appraiser format (הכרעת שמאי מכריע מיום...)
  - Strategy 2: Appeals committee pattern (החלטה בהשגה...)
  - Strategy 3: Appeals board pattern (ערעור/ערר מס'...)
  - Block/plot extraction: 3 patterns (short ג/ח, long גוש/חלקה, parenthesized)
  - Committee extraction: 3 patterns (full name, after נ, with לתו"ב)
  - Appraiser extraction: 3 patterns (after hyphen, שמאי title, after colon)
  - Date extraction: 3 patterns (DD-MM-YYYY variants, מיום keyword, ISO format)
  - Case type extraction: 11 types with priority ordering (היטל השבחה, פיצויים, ירידת ערך, etc.)
- **Learnings for next cycles**:
  - Patterns: Hebrew regex patterns need careful character handling (ג vs גוש, multiple forms)
  - Patterns: Early return after full pattern match improves performance
  - Patterns: Priority-ordered case type matching prevents incorrect classifications
  - Traps: Hebrew text may contain both Hebrew and ASCII quotes ('׳ vs ')
  - Helpful context: ParsedDecision interface defines all required fields in types.ts:79-89

---

## Iteration 3 — US-001 Task 3: Selector health check before full crawl
- **What was done**: Implemented `checkSelectorHealth()` and `checkAllSelectorHealth()` methods to validate selectors against live pages before starting a full crawl
- **Files affected**: `mcp-server/src/scraper.ts`
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `SelectorHealthResult` interface with: database, healthy, timestamp, strategies map, recommendedStrategy, warnings array, optional error
  - `checkSelectorHealth(database)` fetches first page and tests all 3 strategies independently
  - Returns which strategies are working, recommended strategy, and warnings for degradation
  - `checkAllSelectorHealth()` iterates all 3 databases with rate limiting
  - Logs health check progress to stderr
  - Warnings generated for: primary selector failure, low item count (<5), all strategies failing
- **Learnings for next cycles**:
  - Patterns: Health checks should test all strategies independently, not short-circuit
  - Patterns: Return recommended strategy to guide crawl behavior
  - Patterns: Include timestamp in health results for staleness tracking
  - Helpful context: Expected ~10 items per page based on gov.il pagination

---

## Iteration 6 — US-001 Task 6: Log warning when primary selectors fail but fallback succeeds
- **What was done**: Verified existing implementation already logs warnings when fallback strategies are used
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 275 and 285)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Line 275: `console.error('[Scraper] WARNING: Primary CSS selectors failed, structural selectors succeeded')`
  - Line 285: `console.error('[Scraper] WARNING: All CSS selectors failed, using regex fallback')`
  - Warnings are logged to stderr (not stdout) to preserve MCP stdio protocol
  - `logStrategy()` method (lines 202-211) also logs success/failure for each strategy
- **Learnings for next cycles**:
  - Patterns: Check existing code before implementing - this was done in iteration 2
  - Patterns: Always log to stderr in MCP servers to avoid corrupting protocol
  - Helpful context: Multiple iterations may implement related acceptance criteria together

---

## Iteration 7 — US-001 Task 7: Support pagination through ?skip=N parameter
- **What was done**: Verified existing implementation already supports pagination via `?skip=N` parameter
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 229-232 and 237-254)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `buildGovIlUrl(database, skip)` method (lines 229-232): Constructs URL with `?skip=${skip}` parameter
  - `fetchPage(database, page)` method (lines 237-254): Calculates `skip = page * this.pageSize` (10 items per page)
  - `pageSize` constant set to 10 (line 167) matching gov.il's pagination
  - Indexer uses `fetchPage(database, page)` which automatically handles pagination
- **Learnings for next cycles**:
  - Patterns: Pagination was implemented as part of the core fetch mechanism from the start
  - Patterns: `URLSearchParams` provides clean URL building with proper encoding
  - Helpful context: Gov.il uses 10 items per page consistently across all three databases

---

## Iteration 8 — US-001 Task 8: Verify TypeScript type check passes
- **What was done**: Ran TypeScript type check to validate US-001 completion
- **Files affected**: None (validation only)
- **Validation**: `npx tsc --noEmit` succeeds with no errors
- **US-001 COMPLETE**: All acceptance criteria met:
  - [x] Use ScraperAPI with `render=true` and `premium=true` for JavaScript rendering
  - [x] Implement multiple selector strategies with fallbacks
  - [x] Add selector health check that validates selectors before full crawl
  - [x] Parse HTML with Cheerio using adaptive patterns (class-based, structure-based, regex fallback)
  - [x] Extract: title, PDF URL, block, plot, committee, appraiser, case type, dates
  - [x] Log warning when primary selectors fail but fallback succeeds
  - [x] Support pagination through `?skip=N` parameter
  - [x] Typecheck passes

---

## Iteration 9 — US-002 Task 1: SQLite database with FTS5 extension for Hebrew text search
- **What was done**: Replaced sql.js with better-sqlite3 library to enable native FTS5 support for Hebrew full-text search
- **Files affected**:
  - `mcp-server/package.json` (replaced sql.js with better-sqlite3)
  - `mcp-server/src/database.ts` (complete rewrite for better-sqlite3 API)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Replaced `sql.js` (WebAssembly SQLite without FTS5) with `better-sqlite3` (native bindings with FTS5)
  - Created FTS5 virtual table: `decisions_fts` indexing title, committee, appraiser, case_type
  - Uses `unicode61` tokenizer which handles Hebrew text properly
  - External content mode (`content='decisions'`) to avoid data duplication
  - Three triggers (INSERT, DELETE, UPDATE) keep FTS5 index synchronized
  - `search()` method uses FTS5 `MATCH` with `bm25()` relevance ranking
  - `escapeFtsQuery()` helper handles special characters and wraps Hebrew terms in quotes
  - `rebuildFtsIndex()` method for index recovery/migration
  - Changed default db path to `~/.gov-il-mcp/decisions.db` per PRD spec
  - Added WAL mode for better concurrent access
- **Learnings for next cycles**:
  - Patterns: sql.js doesn't support FTS5 - use better-sqlite3 for native FTS5 support
  - Patterns: `unicode61` tokenizer works well for Hebrew text tokenization
  - Patterns: External content FTS5 tables need triggers to stay synchronized
  - Patterns: `bm25()` returns negative scores - order ASC for relevance
  - Traps: FTS5 query syntax has special characters (", -, *, etc.) that need escaping
  - Traps: Hebrew terms should be quoted in FTS5 queries for proper matching
  - Helpful context: better-sqlite3 has synchronous API (simpler than sql.js async)

---

## Iteration 10 — US-002 Task 2: Table schema verification
- **What was done**: Verified existing table schema in database.ts matches PRD specification
- **Files affected**: None (already implemented correctly)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - SQLite table `decisions` has all 12 required columns per PRD
  - Column mapping: id, database, title, url, block, plot, committee, appraiser, case_type, decision_date, publish_date, content_hash, indexed_at
  - Snake_case used in SQL (standard convention), camelCase in TypeScript via `rowToDecision()` converter
  - Additional `pdf_text TEXT` column present for future US-003 (PDF extraction)
  - `Decision` interface in types.ts:8-22 defines all required fields
  - `DecisionRow` interface in types.ts:24-38 defines SQL row structure
  - `rowToDecision()` function in types.ts:135-151 handles conversion
- **Learnings for next cycles**:
  - Patterns: SQL columns use snake_case, TypeScript uses camelCase with converter function
  - Patterns: Schema was implemented correctly in iteration 9 as part of better-sqlite3 migration
  - Helpful context: PRD schema and database.ts schema match exactly

---

## Iteration 11 — US-002 Task 3: FTS5 virtual table indexing
- **What was done**: Verified existing FTS5 virtual table implementation indexes all required columns
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` lines 94-128)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - FTS5 virtual table `decisions_fts` created at lines 94-104
  - Indexes exactly 4 columns per PRD: `title`, `committee`, `appraiser`, `case_type`
  - Uses `unicode61` tokenizer for Hebrew text support
  - External content mode (`content='decisions'`) avoids data duplication
  - Three triggers (INSERT/DELETE/UPDATE) at lines 107-128 keep FTS5 synchronized
  - `search()` method at lines 291-410 uses FTS5 MATCH with bm25() ranking
- **Learnings for next cycles**:
  - Patterns: FTS5 was implemented in iteration 9 alongside better-sqlite3 migration
  - Patterns: Check completion criteria against existing code before starting work
  - Helpful context: PRD column names use camelCase (caseType), SQL uses snake_case (case_type)

---

## Iteration 12 — US-002 Task 4: Support filtering by any combination of fields
- **What was done**: Verified existing implementation already supports filtering by any combination of fields
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` lines 291-410)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `search()` method uses `conditions.push()` pattern to build AND-joined WHERE clause
  - Supported filters that combine freely:
    - `database` (exact match, line 300-303)
    - `committee` (LIKE partial match, line 306-309)
    - `block` (exact match, line 312-315)
    - `plot` (exact match, line 316-319)
    - `appraiser` (LIKE partial match, line 322-325)
    - `caseType` (LIKE partial match, line 328-331)
    - `fromDate`/`toDate` (date range, lines 334-341)
    - `query` (FTS5 full-text search, lines 344-348)
  - All filters work together via: `WHERE ${conditions.join(' AND ')}` (lines 363, 386)
  - `SearchParams` interface in types.ts:41-54 defines all filter fields
- **Learnings for next cycles**:
  - Patterns: The `1=1` base condition (line 294) simplifies dynamic AND clause building
  - Patterns: LIKE with `%value%` provides partial Hebrew name matching
  - Patterns: Exact match for block/plot since these are numeric identifiers
  - Helpful context: Implementation was done in iteration 9 as part of better-sqlite3 migration

---

## Iteration 13 — US-002 Task 5: Support date range queries (fromDate, toDate)
- **What was done**: Verified existing implementation already supports date range queries with fromDate and toDate parameters
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` lines 334-341)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `fromDate` filter: `conditions.push('d.decision_date >= ?')` (lines 334-336)
  - `toDate` filter: `conditions.push('d.decision_date <= ?')` (lines 338-341)
  - Both work with ISO date format strings (YYYY-MM-DD)
  - Can be used together or independently with other filters
  - `SearchParams` interface in types.ts:49-50 defines both optional string parameters
- **Learnings for next cycles**:
  - Patterns: Date comparisons work correctly with SQLite string comparison when using ISO format (YYYY-MM-DD)
  - Patterns: Date range was implemented in iteration 9 as part of better-sqlite3 migration
  - Helpful context: Check existing code for already-implemented features before starting work

---

## Iteration 14 — US-002 Task 6: Return results with relevance ranking
- **What was done**: Added relevance score support to search results when using FTS5 full-text search
- **Files affected**:
  - `mcp-server/src/types.ts` (added relevanceScore to Decision, rankedByRelevance to SearchResult, updated rowToDecision)
  - `mcp-server/src/database.ts` (updated search method to include scores and ranking flag)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added optional `relevanceScore?: number` field to `Decision` interface
  - Added `rankedByRelevance: boolean` field to `SearchResult` interface
  - Updated `rowToDecision()` to accept optional relevance score and normalize bm25 values
  - bm25() returns negative scores (more negative = more relevant), so we negate to get positive scores
  - `rankedByRelevance` is true only when FTS5 text search is used
  - Non-FTS searches order by decision_date DESC, FTS searches order by bm25() ASC (most relevant first)
- **Learnings for next cycles**:
  - Patterns: bm25() returns negative values, negate to get positive relevance scores (higher = better)
  - Patterns: Optional fields in TypeScript interfaces allow gradual data inclusion
  - Patterns: Track whether ranking was applied so consumers know how results are ordered
  - Traps: The `relevance_score` column from SQL query needs to match the row type
  - Helpful context: FTS5 bm25() is efficient - no need for separate relevance computation

---

## Iteration 15 — US-002 Task 7: Index location ~/.gov-il-mcp/decisions.db
- **What was done**: Verified existing implementation already uses correct default path for database
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` line 31)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Default database path in constructor: `path.join(os.homedir(), '.gov-il-mcp', 'decisions.db')`
  - Uses `os.homedir()` for cross-platform home directory resolution
  - Directory auto-created in `initialize()` method (lines 41-44) if not exists
  - Path matches PRD specification: `~/.gov-il-mcp/decisions.db`
- **Learnings for next cycles**:
  - Patterns: Implementation was done in iteration 9 during better-sqlite3 migration
  - Patterns: `os.homedir()` provides cross-platform home directory path
  - Patterns: Always verify existing code before implementing - many tasks already complete
  - Helpful context: The `getDbPath()` method (line 569-571) exposes the path for debugging

---

## Iteration 16 — US-002 Task 8: Verify TypeScript type check passes
- **What was done**: Ran TypeScript type check to validate US-002 completion
- **Files affected**: None (validation only)
- **Validation**: `npx tsc --noEmit` succeeds with no errors
- **US-002 COMPLETE**: All acceptance criteria met:
  - [x] SQLite database with FTS5 extension for Hebrew text search
  - [x] Table schema: id, database, title, url, block, plot, committee, appraiser, caseType, decisionDate, publishDate, contentHash, indexedAt
  - [x] FTS5 virtual table indexing: title, committee, appraiser, caseType
  - [x] Support filtering by any combination of fields
  - [x] Support date range queries (fromDate, toDate)
  - [x] Return results with relevance ranking
  - [x] Index location: `~/.gov-il-mcp/decisions.db`
  - [x] Typecheck passes
- **Learnings for next cycles**:
  - Patterns: better-sqlite3 migration in iteration 9 laid foundation for all US-002 criteria
  - Patterns: Many tasks were already implemented as side effects of earlier iterations
  - Helpful context: US-002 complete, ready to proceed to US-003 (PDF text extraction)

---

## Iteration 17 — US-003 Task 1: Download PDF using ScraperAPI (handles any blocking)
- **What was done**: Created new pdf-extractor.ts module with ScraperAPI-based PDF download capability
- **Files affected**:
  - `mcp-server/src/pdf-extractor.ts` (new file)
  - `mcp-server/src/pdf-parse.d.ts` (new file - type declarations for pdf-parse)
  - `mcp-server/package.json` (added pdf-parse dependency)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `PdfExtractor` class with `downloadPdf()` method using ScraperAPI
  - Uses `premium=true` parameter to bypass blocking (render not needed for PDFs)
  - Validates PDF by checking magic bytes (`%PDF-`)
  - Returns Buffer for downstream text extraction
  - Custom type declaration file for pdf-parse (no @types available)
  - `PdfExtractionResult` interface: { fullText, pageCount, extractedPages, cached }
- **Learnings for next cycles**:
  - Patterns: ScraperAPI doesn't need `render=true` for PDFs since they're not HTML
  - Patterns: `premium=true` helps bypass blocking on gov.il PDF endpoints
  - Patterns: Check PDF magic bytes (`%PDF-`) to validate download success
  - Traps: pdf-parse lacks TypeScript types - need custom .d.ts file
  - Traps: fetch returns ArrayBuffer which needs conversion to Buffer for pdf-parse
  - Helpful context: The extractor module is separate from scraper.ts for clean separation of concerns

---

## Iteration 18 — US-003 Task 2: Extract text using pdf-parse library
- **What was done**: Verified existing implementation already uses pdf-parse for text extraction
- **Files affected**: None (already implemented in `mcp-server/src/pdf-extractor.ts` lines 100-134)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Line 8: `import pdf from 'pdf-parse';` imports the library
  - `extractText(pdfBuffer: Buffer)` method (lines 100-134) handles extraction
  - Uses pdf-parse `options.max` parameter for partial page extraction
  - Returns `PdfExtractionResult` with fullText, pageCount, extractedPages, cached
  - Custom type declarations in `pdf-parse.d.ts` provide TypeScript support
  - `downloadAndExtract()` (lines 140-143) combines download and extraction in one call
- **Learnings for next cycles**:
  - Patterns: pdf-parse accepts Buffer directly, no file system needed
  - Patterns: `data.text` contains all extracted text, `data.numpages` is total page count
  - Patterns: Implementation was done in iteration 17 as part of PDF download task
  - Helpful context: pdf-parse returns text in logical order which works correctly for RTL Hebrew

---

## Iteration 19 — US-003 Task 3: Handle Hebrew RTL text properly
- **What was done**: Implemented comprehensive Hebrew RTL text processing in pdf-extractor.ts
- **Files affected**: `mcp-server/src/pdf-extractor.ts` (added ~130 lines of Hebrew text processing utilities)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added Unicode constants for Hebrew range (0x0590-0x05FF) and RTL control characters
  - `isHebrewChar()` and `containsHebrew()` helper functions for character detection
  - `removeDirectionalControls()` strips all Unicode directional markers (RTL/LTR marks, embeddings, isolates)
  - `normalizeHebrewFinalLetters()` fixes misplaced sofit forms (ך,ם,ן,ף,ץ) - converts finals mid-word to regular and regular at word-end to final
  - `cleanHebrewPdfArtifacts()` handles: zero-width characters, multiple spaces, Hebrew punctuation (״→", ׳→'), excessive line breaks
  - `processHebrewText()` orchestrates all processing steps, only runs if text contains Hebrew
  - Updated `extractText()` method to use `processHebrewText()` on pdf-parse output
- **Learnings for next cycles**:
  - Patterns: Hebrew final letters (sofit) are: ך(כ), ם(מ), ן(נ), ף(פ), ץ(צ)
  - Patterns: Use `[...text]` spread to properly iterate Hebrew characters (handles multi-byte)
  - Patterns: Hebrew punctuation (Gershayim ״, Geresh ׳) differs from ASCII quotes
  - Traps: Unicode directional controls (RTL marks, embeddings) can cause display issues - strip them
  - Traps: PDF extraction often produces excessive line breaks and spacing artifacts
  - Helpful context: Hebrew Unicode range is 0x0590-0x05FF (includes letters, vowels, cantillation)

---

## Iteration 20 — US-003 Task 4: Cache extracted text in database (avoid re-downloading)
- **What was done**: Implemented PDF text caching in SQLite database to avoid redundant downloads
- **Files affected**:
  - `mcp-server/src/types.ts` (added pdfText field to Decision interface and DecisionRow)
  - `mcp-server/src/database.ts` (added getCachedPdfText, savePdfText, hasCachedPdfText methods)
  - `mcp-server/src/pdf-extractor.ts` (added extractWithCache method and database integration)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `pdfText: string | null` field to Decision interface
  - Added `pdf_text: string | null` field to DecisionRow interface
  - Updated `rowToDecision()` to map pdf_text from row to Decision
  - Three new database methods:
    - `getCachedPdfText(decisionId)`: Returns cached text or null
    - `savePdfText(decisionId, text)`: Saves extracted text to cache
    - `hasCachedPdfText(decisionId)`: Quick check if cached
  - `extractWithCache(decisionId, pdfUrl)` method in PdfExtractor:
    - Checks cache first, returns immediately if found (cached=true)
    - Downloads and extracts only on cache miss
    - Saves to cache after successful extraction
  - PdfExtractor accepts optional `database` reference for caching
  - `setDatabase()` method allows late binding of database reference
- **Learnings for next cycles**:
  - Patterns: The `decisions` table already had `pdf_text TEXT` column - just needed to use it
  - Patterns: Cache-aside pattern: check cache → miss → fetch → store → return
  - Patterns: Use `type` import for circular dependency avoidance (`import type { DecisionDatabase }`)
  - Patterns: Page count estimation for cached results: ~3000 chars per page for Hebrew legal docs
  - Traps: Remember to add fields to both Decision interface AND DecisionRow interface
  - Helpful context: SQLite UPDATE returns `changes` count to verify success

---

## Iteration 21 — US-003 Tasks 5-7: Partial extraction, structured output, typecheck
- **What was done**: Verified existing implementation, fixed type errors to pass typecheck, marked US-003 complete
- **Files affected**:
  - `mcp-server/src/pdf-extractor.ts` (line 279: fixed pdf.Options type annotation)
  - `mcp-server/src/scraper.ts` (lines 339, 433, 490: fixed Partial spread to explicit nullable fields; line 449: fixed cheerio.Element type; line 685: added pdfText field)
  - `mcp-server/src/index.ts` (line 543: added explicit return type for MCP handler)
  - `mcp-server/tsconfig.json` (changed rootDir from "./src" to "." to include scripts)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **US-003 COMPLETE**: All acceptance criteria met:
  - [x] Download PDF using ScraperAPI (handles any blocking)
  - [x] Extract text using pdf-parse library
  - [x] Handle Hebrew RTL text properly
  - [x] Cache extracted text in database (avoid re-downloading)
  - [x] Support partial extraction (first N pages) for large PDFs
  - [x] Return structured output: { fullText, pageCount, extractedPages }
  - [x] Typecheck passes
- **Implementation details verified**:
  - Partial extraction: `maxPages` option in PdfExtractor (lines 184, 190, 195, 282-284), `setMaxPages()` method
  - Structured output: `PdfExtractionResult` interface (lines 175-180) with fullText, pageCount, extractedPages, cached
- **Learnings for next cycles**:
  - Patterns: pdf-parse default import doesn't create namespace - use inline type `{ max?: number }` instead of `pdf.Options`
  - Patterns: cheerio Element type changed in newer versions - use `ReturnType<cheerio.CheerioAPI>` for generic element
  - Patterns: Partial<T> spread with nullable fields needs explicit `?? null` coalescing to satisfy `T`
  - Patterns: MCP SDK handler may need explicit return type to satisfy complex type inference
  - Traps: tsconfig rootDir must cover all included directories (scripts/** needs rootDir: "." not "./src")
  - Traps: Decision type with new fields (pdfText) must be updated in all places that construct Decision objects
  - Helpful context: US-003 complete, ready to proceed to US-004 (Hebrew-aware tool descriptions)

---

## Iteration 22 — US-004 Task 1: Include 6+ diverse Hebrew query examples with expected parameter extraction
- **What was done**: Enhanced search_decisions tool description with 8 Hebrew query examples showing expected parameter extraction
- **Files affected**: `mcp-server/src/index.ts` (lines 33-69, major enhancement of search_decisions description)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added database selection table mapping Hebrew keywords to database IDs:
    - "שמאי מכריע", "הכרעה", "הכרעת שמאי" → decisive_appraiser
    - "השגה", "ועדת השגות" → appeals_committee
    - "ערעור", "ועדת ערעורים", "ערר" → appeals_board
  - Added 8 Hebrew query examples with expected parameters (PRD required 6+):
    1. "החלטות בנתניה" → { committee: "נתניה" }
    2. "גוש 6158 חלקה 25" → { block: "6158", plot: "25" }
    3. "היטל השבחה תל אביב" → { caseType: "היטל השבחה", committee: "תל אביב" }
    4. "ערעורים מ-2024" → { database: "appeals_board", fromDate: "2024-01-01" }
    5. "שמאי מכריע כהן" → { database: "decisive_appraiser", appraiser: "כהן" }
    6. "פיצויים על הפקעה" → { caseType: "פיצויים" }
    7. "החלטות השגה בירושלים 2023" → multi-param with date range
    8. "ירידת ערך רעננה" → { caseType: "ירידת ערך", committee: "רעננה" }
  - Added common case types list (10 types)
  - Added "Important Guidelines" with negative guidance about not inventing parameters
  - Specified default database (decisive_appraiser) when unclear
- **Learnings for next cycles**:
  - Patterns: MCP tool descriptions support markdown tables for structured guidance
  - Patterns: Example tables with User Query → Expected Parameters help LLM understand mapping
  - Patterns: Negative guidance ("Don't invent...") prevents hallucination of parameters
  - Patterns: Hebrew year conversion note (תשפ"ד = 2024) helps with date handling
  - Helpful context: This task also partially completes US-004 Tasks 2, 3, 5 (database table, default, negative guidance)

---

## Iteration 23 — US-004 Task 2: Add database selection table mapping Hebrew keywords to databases
- **What was done**: Verified existing implementation already includes database selection table (implemented in iteration 22), marked task complete
- **Files affected**: `mcp-server/src/index.ts` (lines 38-44, already implemented)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Database selection table at lines 38-44 in search_decisions tool description
  - Mappings match PRD specification:
    - "שמאי מכריע", "הכרעה", "הכרעת שמאי" → decisive_appraiser
    - "השגה", "ועדת השגות" → appeals_committee
    - "ערעור", "ועדת ערעורים", "ערר" → appeals_board
  - Extra keywords ("הכרעת שמאי", "ערר") added beyond PRD minimum for better coverage
- **Learnings for next cycles**:
  - Patterns: Check previous iteration notes - work may already be done as side effect
  - Patterns: Iteration 22 notes explicitly stated "This task also partially completes US-004 Tasks 2, 3, 5"
  - Helpful context: Always verify PRD checkboxes match actual code state before starting work

---

## Iteration 24 — US-004 Task 3: Specify default database (decisive_appraiser) when unclear
- **What was done**: Verified existing implementation already specifies default database (implemented in iteration 22), marked task complete
- **Files affected**: `mcp-server/src/index.ts` (line 45, already implemented)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Line 45: `**Default**: If database unclear from query, use decisive_appraiser (largest dataset).`
  - This guidance helps Claude select the default database when no Hebrew keyword matches
- **Learnings for next cycles**:
  - Patterns: Iteration 22 implemented multiple US-004 tasks together (Tasks 2, 3, 5, 6)
  - Patterns: PRD checkboxes must be updated when side-effect work completes tasks
  - Helpful context: US-004 Tasks 3, 4, 5, 6 were all done in iteration 22 but checkboxes lagged

---

## Iteration 25 — US-004 Task 4: Include Hebrew descriptions for all parameters
- **What was done**: Added bilingual Hebrew/English descriptions to all MCP tool parameters
- **Files affected**: `mcp-server/src/index.ts` (lines 71-243, all tool parameter descriptions)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Format: "עברית / English" for all parameter descriptions
  - Updated 9 tools with Hebrew descriptions:
    - `search_decisions`: 12 parameters (query, database, committee, block, plot, appraiser, caseType, fromDate, toDate, limit, offset, semanticSearch)
    - `get_decision`: 1 parameter (id)
    - `get_decision_pdf`: 1 parameter (id)
    - `get_statistics`: no parameters (but tool description updated)
    - `list_committees`: 1 parameter (limit)
    - `list_appraisers`: 1 parameter (limit)
    - `compare_decisions`: 1 parameter (ids)
    - `semantic_search`: 3 parameters (query, limit, database)
    - `trigger_update`: 1 parameter (pagesToCheck)
  - Added examples in Hebrew where helpful (e.g., "לדוגמה: תל אביב, ירושלים")
  - Included database ID mapping in database parameter descriptions
- **Learnings for next cycles**:
  - Patterns: Bilingual format "עברית / English" works well for MCP tools that may be used by Hebrew speakers
  - Patterns: Examples in Hebrew ("לדוגמה:") help Claude understand expected values
  - Patterns: Including database name mappings in description avoids need for separate lookup
  - Helpful context: Tool descriptions and parameter descriptions are shown to Claude when using MCP tools

---

## Iteration 26 — US-004 Task 5: Add negative guidance "Don't invent parameters user didn't mention"
- **What was done**: Enhanced the "Important Guidelines" section in search_decisions tool with explicit negative guidance matching PRD wording
- **Files affected**: `mcp-server/src/index.ts` (lines 62-70, enhanced Important Guidelines section)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Renamed section header: "## הנחיות חשובות / Important Guidelines (CRITICAL)"
  - Added bold Hebrew+English negative guidance: "**אל תמציא פרמטרים שהמשתמש לא ציין / Don't invent parameters user didn't mention:**"
  - Expanded guidance from 4 to 7 bullet points:
    1. Extract ONLY parameters the user explicitly mentioned in their query
    2. Don't invent block/plot numbers if not stated - leave them empty
    3. Don't assume database if no keywords match the table above - use default
    4. Don't add caseType unless user mentioned a specific case type
    5. Don't guess committee/city names - only use what user wrote
    6. For date ranges, convert Hebrew years (תשפ"ד = 2024) to Gregorian
    7. When in doubt, use FEWER parameters rather than guessing
- **Learnings for next cycles**:
  - Patterns: Negative guidance in MCP tool descriptions helps prevent LLM parameter hallucination
  - Patterns: Making guidance section "CRITICAL" with bold formatting draws attention
  - Patterns: Hebrew+English bilingual format maintains consistency with rest of tool description
  - Patterns: "When in doubt, use FEWER parameters" is a good heuristic for search tools
  - Helpful context: Iteration 22 had partial negative guidance, this iteration made it more explicit and comprehensive

---

## Iteration 27 — US-004 Task 6: Document common case types
- **What was done**: Expanded the "Common Case Types" section with full documentation table including English translations and descriptions
- **Files affected**: `mcp-server/src/index.ts` (lines 59-73, expanded from simple list to full documentation table)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Converted simple comma-separated list to markdown table with 3 columns
  - Documented 10 case types per PRD:
    - היטל השבחה (Betterment Levy) - Tax on property value increase due to planning
    - פיצויים (Compensation) - Compensation for planning restrictions
    - ירידת ערך (Depreciation) - Claims for property value decrease
    - הפקעה (Expropriation) - Land expropriation for public purposes
    - תכנית מתאר (Master Plan) - Master/outline plan disputes
    - שינוי ייעוד (Zoning Change) - Land use designation changes
    - היתר בניה (Building Permit) - Building permit disputes
    - תמ"א 38 (TAMA 38) - Earthquake reinforcement program disputes
    - פינוי בינוי (Urban Renewal) - Urban renewal projects
    - תב"ע (Zoning Plan) - Local zoning plan disputes
  - Added mapping tip: "When user mentions these terms, use exact Hebrew value for caseType parameter"
- **Learnings for next cycles**:
  - Patterns: Table format with English translations helps LLM understand Hebrew legal terms
  - Patterns: Including description helps Claude explain results to users
  - Patterns: "Mapping tip" at end reinforces how to use the information
  - Helpful context: PRD asked for 3 examples but documenting all 10 provides comprehensive coverage

---

## Iteration 28 — US-004 Task 7: Verify TypeScript type check passes
- **What was done**: Ran TypeScript type check to validate US-004 completion
- **Files affected**: None (validation only)
- **Validation**: `npx tsc --noEmit` succeeds with no errors
- **US-004 COMPLETE**: All acceptance criteria met:
  - [x] Include 6+ diverse Hebrew query examples with expected parameter extraction
  - [x] Add database selection table mapping Hebrew keywords to databases
  - [x] Specify default database (decisive_appraiser) when unclear
  - [x] Include Hebrew descriptions for all parameters
  - [x] Add negative guidance: "Don't invent parameters user didn't mention"
  - [x] Document common case types: היטל השבחה, פיצויים, ירידת ערך
  - [x] Typecheck passes
- **Learnings for next cycles**:
  - Patterns: US-004 Tasks 1-6 were implemented across iterations 22-27
  - Patterns: Task 7 (typecheck) serves as final validation gate for user story completion
  - Helpful context: US-004 complete, ready to proceed to US-005 (query clarification tool)

---

## Iteration 29 — US-005 Task 1: Tool clarify_query that returns structured clarification prompts
- **What was done**: Implemented `clarify_query` MCP tool with comprehensive ambiguity detection and Hebrew clarification prompts
- **Files affected**:
  - `mcp-server/src/types.ts` (added 5 new types: AmbiguityType, ClarificationOption, ClarificationPrompt, ClarifyQueryInput, ClarifyQueryResult)
  - `mcp-server/src/index.ts` (added tool definition, CLARIFICATION_PROMPTS constant, detection patterns, handleClarifyQuery handler)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `AmbiguityType` union type: 'missing_database' | 'vague_location' | 'unclear_date_range' | 'ambiguous_case_type' | 'missing_search_terms'
  - Created `CLARIFICATION_PROMPTS` constant with Hebrew+English questions and multiple-choice options
  - Added detection patterns:
    - `DATABASE_KEYWORDS`: Maps database types to Hebrew keywords (שמאי מכריע, השגה, ערעור, etc.)
    - `CASE_TYPE_KEYWORDS`: 10 case types from PRD (היטל השבחה, פיצויים, etc.)
    - `YEAR_PATTERN`: Regex for Gregorian (20\d{2}) and Hebrew years (תשפ"ד)
    - `BLOCK_PLOT_PATTERN`: Regex for גוש/חלקה patterns
    - `commonCities`: Array of 10 major Israeli cities
  - Handler logic:
    - Detects missing database keywords → suggests database selection
    - Detects vague location (no city or block/plot) → suggests location clarification
    - Detects year without date range → suggests date range options
    - Detects general legal terms without case type → suggests case type selection
    - Extracts suggested parameters even when ambiguous
    - Respects `previousClarifications` to avoid asking same question twice
  - Tool description includes usage flow and examples
- **Learnings for next cycles**:
  - Patterns: Use Record<AmbiguityType, ClarificationPrompt> for type-safe prompt lookup
  - Patterns: Hebrew year patterns need multiple regex alternatives (תשפ"ד variants)
  - Patterns: Tool descriptions with markdown tables help Claude understand when/how to use the tool
  - Patterns: Include both Hebrew and English in options for better LLM understanding
  - Traps: Query length check should come first to avoid other ambiguity checks on very short queries
  - Helpful context: This task partially implements Tasks 2, 3, 4 of US-005 (ambiguity detection, Hebrew questions, previousClarifications)

---

## Iteration 30 — US-005 Tasks 2-6: Complete query clarification tool validation
- **What was done**: Verified existing implementation and marked remaining US-005 tasks complete
- **Files affected**: `PRD.md` (marked checkboxes), no code changes needed
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **US-005 COMPLETE**: All acceptance criteria met:
  - [x] Tool: `clarify_query` that returns structured clarification prompts
  - [x] Detect ambiguity patterns: missing database, vague location, unclear date range
  - [x] Generate Hebrew clarification questions with multiple-choice options
  - [x] Example: "באיזה מאגר לחפש?" with options [שמאי מכריע, ועדת השגות, ועדת ערעורים]
  - [x] Track clarification state to avoid asking same question twice
  - [x] Typecheck passes
- **Implementation verified**:
  - Ambiguity detection (index.ts:690-742): Detects 5 types - missing_database, vague_location, unclear_date_range, ambiguous_case_type, missing_search_terms
  - Hebrew questions (index.ts:601-660): CLARIFICATION_PROMPTS constant with Hebrew+English questions and multiple-choice options
  - Example implementation (index.ts:602-613): Exact PRD example "באיזה מאגר לחפש?" with [שמאי מכריע, ועדת השגות, ועדת ערעורים] options
  - Clarification tracking (index.ts:683): Uses `previousClarifications` array to skip already-asked questions
- **Learnings for next cycles**:
  - Patterns: Iteration 29 implemented comprehensive solution covering all US-005 acceptance criteria
  - Patterns: Always verify full implementation before marking tasks incomplete - code may already satisfy multiple criteria
  - Patterns: PRD checkbox updates can lag behind actual implementation
  - Helpful context: US-005 complete, ready to proceed to US-006 (answer construction with citations)

---

## Iteration 31 — US-006 Task 1: Format answers with inline citations [S0], [S1], etc.
- **What was done**: Implemented `construct_answer` MCP tool with inline citation formatting
- **Files affected**:
  - `mcp-server/src/types.ts` (added 6 new types: ConfidenceLevel, CitedSource, CitedClaim, ConstructAnswerInput, ConstructAnswerResult)
  - `mcp-server/src/index.ts` (added tool definition, handleConstructAnswer handler, switch case)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `ConfidenceLevel` type: 'confident' | 'uncertain'
  - Created `CitedSource` interface with: index (for [S0]), decisionId, title, pdfUrl, database, relevanceScore, optional excerpt
  - Created `CitedClaim` interface: text, citations array (indices), confidence level
  - Created `ConstructAnswerInput` interface: question, decisions array, optional pdfExcerpts
  - Created `ConstructAnswerResult` interface: formattedAnswer, sources, claims, overallConfidence, optional noResultsWarning
  - Tool description includes Hebrew+English documentation with usage examples
  - Citation format: [S0], [S1], [S2], etc. (S = Source)
  - Handler builds sources array mapping decisions to citation indices
  - Confidence determined by: number of results, relevance scores
  - No results case returns Hebrew warning: "לא נמצאו החלטות רלוונטיות לשאילתה זו"
- **Learnings for next cycles**:
  - Patterns: Citation indices start at 0 ([S0]) for consistent array indexing
  - Patterns: Handler returns structured data for Claude to use when constructing actual response text
  - Patterns: Confidence thresholds: >=3 decisions or single decision with >0.8 relevance = confident
  - Patterns: Tool descriptions with markdown examples help Claude understand citation placement
  - Helpful context: US-006 Task 1 complete, remaining tasks (2-6): sources section, claim citations, PDF excerpts, confidence indicators, no-results warning

---

## Iteration 32 — US-006 Task 2: Include sources section with decision ID, title, PDF URL, relevance score
- **What was done**: Enhanced `handleConstructAnswer` to include a detailed sources section with all required fields
- **Files affected**: `mcp-server/src/index.ts` (lines 939-972, added sourcesSection builder and updated formattedAnswer template)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `sourcesSection` variable that maps each source to a formatted block
  - Each source block includes:
    - `[S#]` bold header for citation reference
    - Decision ID in code format (`decisionId`)
    - Title (Hebrew/English)
    - PDF URL with fallback text "לא זמין / Not available" when null
    - Relevance Score as percentage (e.g., "85%") or "N/A" when undefined
    - Optional Excerpt truncated to 200 characters
  - Added horizontal rule separators (`---`) for visual clarity
  - Renamed section header from "Available Sources" to "מקורות / Sources Section"
- **Learnings for next cycles**:
  - Patterns: Use Math.round(score * 100) + '%' for human-readable relevance percentages
  - Patterns: Bilingual labels (Hebrew / English) maintain consistency with rest of tool descriptions
  - Patterns: Template literals with conditional expressions for optional fields (excerpt)
  - Patterns: Truncate long excerpts with length check + ellipsis for readability
  - Helpful context: US-006 Task 2 complete, remaining tasks (3-6): claim citations, PDF excerpts, confidence indicators, no-results warning

---

## Iteration 33 — US-006 Task 3: For each claim, cite the specific decision(s) supporting it
- **What was done**: Implemented `generateClaimsFromSources` helper function that extracts claims from question and decisions, mapping each claim to specific source indices
- **Files affected**: `mcp-server/src/index.ts` (added ~140 line helper function, updated handleConstructAnswer to use it)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Groups decisions by shared attributes: block, committee, caseType, appraiser using Map<string, number[]>
  - Generates location-based claims when query contains גוש/חלקה patterns
  - Generates committee-based claims when query mentions ועדה or city names
  - Generates case-type claims when query matches known case types (היטל השבחה, פיצויים, etc.)
  - Generates appraiser claims when query mentions שמאי/מעריך
  - Generates claims from PDF excerpts with direct quotes (high confidence)
  - Falls back to per-decision summary claims when no specific patterns detected
  - Each claim includes: text (Hebrew), citations array (indices to sources), confidence level
- **Learnings for next cycles**:
  - Patterns: Use Map<string, number[]> to group items by attribute while tracking indices
  - Patterns: Multiple overlapping claims with different citation sets provide comprehensive coverage
  - Patterns: PDF excerpt claims get 'confident' rating since they're direct quotes
  - Patterns: Relevance score threshold (0.6) determines claim confidence level
  - Patterns: Fallback to simple decision summaries ensures claims array is never empty
  - Helpful context: US-006 Task 3 complete, remaining tasks (4-6): PDF excerpts, confidence indicators, no-results warning

---

## Iteration 34 — US-006 Task 4: When answering from PDF content, quote relevant excerpts
- **What was done**: Implemented comprehensive PDF excerpt quoting with Hebrew quotation marks, key phrase extraction, and a dedicated "Quoted Excerpts" section in the formatted answer
- **Files affected**:
  - `mcp-server/src/types.ts` (added QuotedExcerpt interface, added quotedExcerpts field to ConstructAnswerResult)
  - `mcp-server/src/index.ts` (added formatPdfExcerpt helper, extractKeyPhrasesFromExcerpt helper, enhanced handleConstructAnswer with quotedExcerpts section)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `QuotedExcerpt` interface with: sourceIndex, decisionId, excerpt (formatted), optional context
  - `formatPdfExcerpt()` helper function:
    - Normalizes whitespace and limits consecutive newlines
    - Truncates at word boundary (default 500 chars)
    - Uses Hebrew quotation marks (״...״) for Hebrew text, standard quotes for English
  - `extractKeyPhrasesFromExcerpt()` helper function:
    - Extracts monetary amounts (ש"ח, שקל, ₪ patterns)
    - Extracts percentages (\d+%)
    - Extracts dates (DD/MM/YYYY, DD.MM.YYYY patterns)
    - Extracts legal determination keywords (נקבע כי, הוחלט, נדחה, etc.)
  - Enhanced `handleConstructAnswer`:
    - Builds `quotedExcerpts` array from pdfExcerpts input
    - Creates dedicated "ציטוטים מתוך ה-PDF / Quoted Excerpts" section in formattedAnswer
    - Each excerpt shows source reference [S#], formatted quote, and key context
    - Added guideline #5 about using PDF quotes to support answers
  - Updated ConstructAnswerResult to include `quotedExcerpts` field in both success and no-results cases
- **Learnings for next cycles**:
  - Patterns: Hebrew uses ״...״ (Unicode U+05F4) for quotation marks, different from standard quotes
  - Patterns: `/[\u0590-\u05FF]/` regex detects Hebrew characters reliably
  - Patterns: Breaking truncation at word boundary (lastIndexOf(' ')) prevents mid-word cuts
  - Patterns: Key phrase extraction improves context awareness for answer construction
  - Patterns: Legal determination keywords (נקבע כי, הוחלט, הפיצוי) signal important content
  - Traps: QuotedExcerpt must be added to both imports in index.ts and types.ts exports
  - Helpful context: US-006 Task 4 complete, remaining tasks (5-6): confidence indicators, no-results warning

---

## Iteration 35 — US-006 Task 5: Add confidence indicator "בטוח" (confident) vs "ייתכן" (uncertain)
- **What was done**: Added prominent confidence indicator to `ConstructAnswerResult` and formatted answer output
- **Files affected**:
  - `mcp-server/src/types.ts` (added `confidenceIndicator: string` field to ConstructAnswerResult interface)
  - `mcp-server/src/index.ts` (added confidence indicator section to formattedAnswer, Hebrew label to result object, fixed type casting issues)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added new `confidenceIndicator` field to ConstructAnswerResult interface - holds "בטוח" or "ייתכן"
  - Created prominent "רמת ביטחון / Confidence Level" section at top of formattedAnswer
  - Confidence display includes colored emoji indicator (🟢 for confident, 🟡 for uncertain)
  - Added bilingual explanation of confidence based on number of sources and relevance scores
  - Updated no-results case to include `confidenceIndicator: 'ייתכן'`
  - Updated guideline #4 to instruct Claude to use confidence indicator in responses
  - Fixed pre-existing type casting issues (args as unknown as Type pattern)
- **Learnings for next cycles**:
  - Patterns: Hebrew "בטוח" = confident, "ייתכן" = uncertain (maybe/possibly)
  - Patterns: Place confidence section at TOP of formatted answer for visibility
  - Patterns: Use colored emoji (🟢/🟡) for visual confidence indicator in markdown
  - Patterns: Include both Hebrew and English explanation for bilingual support
  - Patterns: When TypeScript complains about `Record<string, unknown>` to specific type, use `as unknown as Type` pattern
  - Helpful context: US-006 Task 5 complete, remaining tasks (6-7): no-results warning, typecheck passes

---

## Iteration 36 — US-006 Task 6: Warn when no relevant decisions found: "לא נמצאו החלטות רלוונטיות"
- **What was done**: Enhanced the no-results case in `handleConstructAnswer` to include a comprehensive formatted warning in `formattedAnswer` instead of empty string
- **Files affected**: `mcp-server/src/index.ts` (lines 1093-1128, expanded no-results handling)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Changed `noResultsWarning` from long suggestion-text to exact PRD wording: "לא נמצאו החלטות רלוונטיות"
  - Created `formattedNoResultsAnswer` template with:
    - Warning header with emoji: `## ⚠️ לא נמצאו החלטות רלוונטיות`
    - English translation: "No relevant decisions found"
    - Bilingual suggestions section with 3 improvement tips (refine search, check database, clarify query)
    - Confidence level footer showing 🟡 uncertain status
  - The `noResultsWarning` field now contains the exact PRD-specified text
  - The `formattedAnswer` field now contains the full human-readable warning instead of empty string
- **Learnings for next cycles**:
  - Patterns: Empty `formattedAnswer` is poor UX - always provide meaningful content even on no-results
  - Patterns: No-results warnings should include actionable suggestions, not just error messages
  - Patterns: PRD acceptance criteria often have exact text requirements - match them precisely
  - Patterns: Use emoji indicators (⚠️, 🟡) consistently with rest of formatting for visual consistency
  - Helpful context: US-006 Task 6 complete, remaining task (7): typecheck passes validation

---

## Iteration 37 — US-006 Task 7: Verify TypeScript type check passes
- **What was done**: Ran TypeScript type check to validate US-006 completion
- **Files affected**: None (validation only)
- **Validation**: `npx tsc --noEmit` succeeds with no errors
- **US-006 COMPLETE**: All acceptance criteria met:
  - [x] Format answers with inline citations: "[S0]", "[S1]", etc.
  - [x] Include sources section with: decision ID, title, PDF URL, relevance score
  - [x] For each claim, cite the specific decision(s) supporting it
  - [x] When answering from PDF content, quote relevant excerpts
  - [x] Add confidence indicator: "בטוח" (confident) vs "ייתכן" (uncertain)
  - [x] Warn when no relevant decisions found: "לא נמצאו החלטות רלוונטיות"
  - [x] Typecheck passes
- **Learnings for next cycles**:
  - Patterns: US-006 Tasks 1-6 were implemented across iterations 31-36
  - Patterns: Task 7 (typecheck) serves as final validation gate for user story completion
  - Patterns: construct_answer tool provides structured citation data for answer construction
  - Helpful context: US-006 complete, ready to proceed to US-007 (incremental update mechanism)

---

## Iteration 38 — US-007 Task 1: Tool `trigger_update` checks first N pages for new decisions
- **What was done**: Verified existing implementation already provides `trigger_update` tool with configurable page count
- **Files affected**: None (already implemented in `mcp-server/src/index.ts` and `mcp-server/src/indexer.ts`)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `trigger_update` tool definition at index.ts:259-269 with `pagesToCheck` parameter (default: 5)
  - `handleTriggerUpdate()` at index.ts:628-681 validates SCRAPER_API_KEY, creates indexer, calls updateRecent
  - `updateRecent(pagesToCheck)` at indexer.ts:154-197 iterates through pages 0 to N-1
  - Returns JSON with `newDecisionsFound`, `byDatabase` breakdown, and timestamp
  - Calls `scraper.fetchAndParse(database, page)` for each page
  - Checks `existsByHash()` before inserting to avoid duplicates
  - Logs to console: `${DATABASE_CONFIG[database].name} page ${page}: ${newCount} new of ${decisions.length}`
- **Learnings for next cycles**:
  - Patterns: `trigger_update` was implemented during initial MCP server setup
  - Patterns: Check existing code before implementing - incremental update logic already exists
  - Patterns: The tool returns structured JSON suitable for Claude to format as response
  - Helpful context: US-007 Task 1 complete, remaining tasks (2-6): content hash detection, skip indexed, log format, lastUpdateAt, cron script

---

## Iteration 39 — US-007 Task 2: Compare content hash to detect duplicates
- **What was done**: Verified existing implementation already compares content hashes to detect duplicates
- **Files affected**: None (already implemented in `mcp-server/src/indexer.ts` and `mcp-server/src/database.ts`)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Content hash generation in scraper.ts:695-715 uses MD5 of `title|url|database`
  - `existsByHash(contentHash)` method in database.ts:277-285 checks for existing hash
  - `updateRecent()` in indexer.ts:168-173 calls `existsByHash()` before inserting:
    ```typescript
    if (!this.db!.existsByHash(decision.contentHash)) {
      this.db!.insertDecision(decision);
      newCount++;
    }
    ```
  - Database has index on content_hash column for efficient lookups (database.ts:89)
- **Learnings for next cycles**:
  - Patterns: Content hash is derived from MD5 of `title|url|database` - covers core identity
  - Patterns: Check existing code thoroughly - many US-007 tasks were implemented early
  - Patterns: Hash-based deduplication is already integrated into updateRecent() flow
  - Helpful context: US-007 Task 2 complete, remaining tasks (3-6): skip indexed, log format, lastUpdateAt, cron script

---

## Iteration 40 — US-007 Task 3: Skip already-indexed decisions
- **What was done**: Verified existing implementation already skips indexed decisions using `existsByHash()` check
- **Files affected**: None (already implemented in `mcp-server/src/indexer.ts` and `mcp-server/src/database.ts`)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `updateRecent()` at indexer.ts:168-173 calls `existsByHash()` before inserting:
    ```typescript
    if (!this.db!.existsByHash(decision.contentHash)) {
      this.db!.insertDecision(decision);
      newCount++;
    }
    ```
  - `existsByHash(contentHash)` at database.ts:277-285 queries `SELECT 1 FROM decisions WHERE content_hash = ?`
  - `insertDecision()` at database.ts:181-188 also checks `SELECT 1 FROM decisions WHERE id = ? AND content_hash = ?` before insert
  - `insertDecisions()` (batch) at database.ts:234-235 uses same check pattern in transaction
  - Both methods return count of actually inserted records (skipped decisions not counted)
- **Learnings for next cycles**:
  - Patterns: Skip logic was implemented as part of content hash comparison (Task 2) - they are tightly coupled
  - Patterns: Double-checking in both `existsByHash()` and `insertDecision()` provides defense in depth
  - Patterns: Check database.ts insert methods to confirm skip behavior - not just indexer
  - Helpful context: US-007 Task 3 complete, remaining tasks (4-7): log format, lastUpdateAt, cron script, typecheck

---

