# Progress Log

## Learnings
(Notes discovered during implementation)

### Pre-Implementation Research (2026-01-20)

**Gov.il Site Structure:**
- All three databases use AngularJS with client-side rendering
- Dynamic content loaded via `ng-controller="dynamicCtrl"`
- Pagination: `?skip=N` parameter (10 items per page)
- PDF URLs pattern: `https://free-justice.openapi.gov.il/...`
- Search autocomplete: `https://searchgov.gov.il/govil/Suggestext/`

**Existing Code Issues (from QA-FINDINGS.md):**
- 19 issues identified, 3 CRITICAL
- ALL CSS selectors are outdated
- Tool name mismatch: README says `search_land_decisions`, code has `search_decisions`
- Non-existent `search_and_read` tool documented but not implemented
- Angular wait timeout too short (2s fallback)
- No filter success verification

**Working Components:**
- SQLite database layer (`mcp-server/src/database.ts`) - GOOD
- Type definitions (`mcp-server/src/types.ts`) - GOOD
- Indexer logic (`mcp-server/src/indexer.ts`) - GOOD
- Basic MCP server structure (`mcp-server/src/index.ts`) - GOOD

**Broken Components:**
- Scraper selectors (`mcp-server/src/scraper.ts`) - BROKEN
- Puppeteer flow (`mcp-server-live/src/`) - BROKEN

**Key Design Decisions:**
1. Keep SQLite + FTS5 approach (proven to work)
2. Rebuild scraper with multiple fallback strategies
3. Add selector health check before full crawl
4. Improve tool descriptions with Hebrew examples
5. Add query clarification tool for ambiguous queries

---

## Iteration 1 — US-001 Task 1: ScraperAPI render/premium configuration
- **What was done**: Verified existing implementation in scraper.ts already uses `render=true` and `premium=true` as defaults
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 32-33 and 40-45)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Learnings for next cycles**:
  - Patterns: ScraperAPI URL built via `URLSearchParams` with api_key, url, render, premium params
  - Patterns: `buildScraperUrl()` method centralizes URL construction
  - Helpful context: The scraper defaults to premium=true and render=true via nullish coalescing (`??`)

---

## Iteration 2 — US-001 Task 2: Multiple selector strategies with fallbacks
- **What was done**: Implemented multi-strategy fallback system for resilient HTML parsing
- **Files affected**: `mcp-server/src/scraper.ts` (major refactor of parseDecisions method)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `SelectorStrategyType` type: 'css_primary' | 'css_structural' | 'regex_fallback'
  - Created `SelectorConfig` interface with configurable selectors for each strategy
  - Implemented `DEFAULT_SELECTORS` constant with:
    - Primary selectors: class-based (e.g., `.dynamic-card`, `.result-item`)
    - Structural selectors: tag/attribute-based (e.g., `div[ng-repeat]`, `article`)
    - Regex patterns: raw HTML extraction (e.g., `/הכרעת שמאי[^<\n]{10,200}/g`)
  - Strategy tracking: `lastStrategyUsed`, `strategyStats` map
  - Helper methods: `getLastStrategyUsed()`, `getStrategyStats()`, `logStrategy()`
  - Refactored `parseDecisions()` to call strategies in order and log warnings on fallback
- **Learnings for next cycles**:
  - Patterns: Cheerio CheerioAPI type for $ parameter in helper methods
  - Patterns: Use `cheerio.Cheerio<cheerio.Element>` for element wrappers
  - Traps: Regex patterns must be reset (use `g` flag) or create new instances per match
  - Traps: HTML capture groups need cleaning with `.replace(/<[^>]*>/g, '')`
  - Helpful context: Logging to stderr (not stdout) preserves MCP stdio protocol

---

## Iteration 4 — US-001 Task 4: Parse HTML with Cheerio using adaptive patterns
- **What was done**: Verified existing implementation of adaptive Cheerio parsing with three extraction strategies
- **Files affected**: `mcp-server/src/scraper.ts` (already implemented in iteration 2, marking as complete)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `parseWithCssPrimary()` (lines 299-350): Uses class-based selectors like `.dynamic-card`, `.result-item`
  - `parseWithCssStructural()` (lines 355-375): Uses tag/attribute-based selectors like `div[ng-repeat]`, `article`
  - `parseWithRegex()` (lines 380-442): Uses regex patterns for raw HTML extraction
  - `parseDecisions()` (lines 260-294): Orchestrates all three strategies with automatic fallback
  - Warning logs when primary selectors fail but fallback succeeds (line 275, 285)
- **Learnings for next cycles**:
  - Patterns: Code implemented in iteration 2 covered multiple acceptance criteria
  - Patterns: Check existing implementation before assuming work is needed
  - Helpful context: DEFAULT_SELECTORS constant (lines 79-160) contains all selector configurations

---

## Iteration 5 — US-001 Task 5: Extract title, PDF URL, block, plot, committee, appraiser, case type, dates
- **What was done**: Enhanced `parseTitleMetadata()` method with comprehensive extraction patterns for all three databases
- **Files affected**: `mcp-server/src/scraper.ts` (lines 501-650, major refactor of parseTitleMetadata)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Strategy 1: Full pattern for decisive appraiser format (הכרעת שמאי מכריע מיום...)
  - Strategy 2: Appeals committee pattern (החלטה בהשגה...)
  - Strategy 3: Appeals board pattern (ערעור/ערר מס'...)
  - Block/plot extraction: 3 patterns (short ג/ח, long גוש/חלקה, parenthesized)
  - Committee extraction: 3 patterns (full name, after נ, with לתו"ב)
  - Appraiser extraction: 3 patterns (after hyphen, שמאי title, after colon)
  - Date extraction: 3 patterns (DD-MM-YYYY variants, מיום keyword, ISO format)
  - Case type extraction: 11 types with priority ordering (היטל השבחה, פיצויים, ירידת ערך, etc.)
- **Learnings for next cycles**:
  - Patterns: Hebrew regex patterns need careful character handling (ג vs גוש, multiple forms)
  - Patterns: Early return after full pattern match improves performance
  - Patterns: Priority-ordered case type matching prevents incorrect classifications
  - Traps: Hebrew text may contain both Hebrew and ASCII quotes ('׳ vs ')
  - Helpful context: ParsedDecision interface defines all required fields in types.ts:79-89

---

## Iteration 3 — US-001 Task 3: Selector health check before full crawl
- **What was done**: Implemented `checkSelectorHealth()` and `checkAllSelectorHealth()` methods to validate selectors against live pages before starting a full crawl
- **Files affected**: `mcp-server/src/scraper.ts`
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Added `SelectorHealthResult` interface with: database, healthy, timestamp, strategies map, recommendedStrategy, warnings array, optional error
  - `checkSelectorHealth(database)` fetches first page and tests all 3 strategies independently
  - Returns which strategies are working, recommended strategy, and warnings for degradation
  - `checkAllSelectorHealth()` iterates all 3 databases with rate limiting
  - Logs health check progress to stderr
  - Warnings generated for: primary selector failure, low item count (<5), all strategies failing
- **Learnings for next cycles**:
  - Patterns: Health checks should test all strategies independently, not short-circuit
  - Patterns: Return recommended strategy to guide crawl behavior
  - Patterns: Include timestamp in health results for staleness tracking
  - Helpful context: Expected ~10 items per page based on gov.il pagination

---

## Iteration 6 — US-001 Task 6: Log warning when primary selectors fail but fallback succeeds
- **What was done**: Verified existing implementation already logs warnings when fallback strategies are used
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 275 and 285)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Line 275: `console.error('[Scraper] WARNING: Primary CSS selectors failed, structural selectors succeeded')`
  - Line 285: `console.error('[Scraper] WARNING: All CSS selectors failed, using regex fallback')`
  - Warnings are logged to stderr (not stdout) to preserve MCP stdio protocol
  - `logStrategy()` method (lines 202-211) also logs success/failure for each strategy
- **Learnings for next cycles**:
  - Patterns: Check existing code before implementing - this was done in iteration 2
  - Patterns: Always log to stderr in MCP servers to avoid corrupting protocol
  - Helpful context: Multiple iterations may implement related acceptance criteria together

---

## Iteration 7 — US-001 Task 7: Support pagination through ?skip=N parameter
- **What was done**: Verified existing implementation already supports pagination via `?skip=N` parameter
- **Files affected**: None (already implemented in `mcp-server/src/scraper.ts` lines 229-232 and 237-254)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `buildGovIlUrl(database, skip)` method (lines 229-232): Constructs URL with `?skip=${skip}` parameter
  - `fetchPage(database, page)` method (lines 237-254): Calculates `skip = page * this.pageSize` (10 items per page)
  - `pageSize` constant set to 10 (line 167) matching gov.il's pagination
  - Indexer uses `fetchPage(database, page)` which automatically handles pagination
- **Learnings for next cycles**:
  - Patterns: Pagination was implemented as part of the core fetch mechanism from the start
  - Patterns: `URLSearchParams` provides clean URL building with proper encoding
  - Helpful context: Gov.il uses 10 items per page consistently across all three databases

---

## Iteration 8 — US-001 Task 8: Verify TypeScript type check passes
- **What was done**: Ran TypeScript type check to validate US-001 completion
- **Files affected**: None (validation only)
- **Validation**: `npx tsc --noEmit` succeeds with no errors
- **US-001 COMPLETE**: All acceptance criteria met:
  - [x] Use ScraperAPI with `render=true` and `premium=true` for JavaScript rendering
  - [x] Implement multiple selector strategies with fallbacks
  - [x] Add selector health check that validates selectors before full crawl
  - [x] Parse HTML with Cheerio using adaptive patterns (class-based, structure-based, regex fallback)
  - [x] Extract: title, PDF URL, block, plot, committee, appraiser, case type, dates
  - [x] Log warning when primary selectors fail but fallback succeeds
  - [x] Support pagination through `?skip=N` parameter
  - [x] Typecheck passes

---

## Iteration 9 — US-002 Task 1: SQLite database with FTS5 extension for Hebrew text search
- **What was done**: Replaced sql.js with better-sqlite3 library to enable native FTS5 support for Hebrew full-text search
- **Files affected**:
  - `mcp-server/package.json` (replaced sql.js with better-sqlite3)
  - `mcp-server/src/database.ts` (complete rewrite for better-sqlite3 API)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - Replaced `sql.js` (WebAssembly SQLite without FTS5) with `better-sqlite3` (native bindings with FTS5)
  - Created FTS5 virtual table: `decisions_fts` indexing title, committee, appraiser, case_type
  - Uses `unicode61` tokenizer which handles Hebrew text properly
  - External content mode (`content='decisions'`) to avoid data duplication
  - Three triggers (INSERT, DELETE, UPDATE) keep FTS5 index synchronized
  - `search()` method uses FTS5 `MATCH` with `bm25()` relevance ranking
  - `escapeFtsQuery()` helper handles special characters and wraps Hebrew terms in quotes
  - `rebuildFtsIndex()` method for index recovery/migration
  - Changed default db path to `~/.gov-il-mcp/decisions.db` per PRD spec
  - Added WAL mode for better concurrent access
- **Learnings for next cycles**:
  - Patterns: sql.js doesn't support FTS5 - use better-sqlite3 for native FTS5 support
  - Patterns: `unicode61` tokenizer works well for Hebrew text tokenization
  - Patterns: External content FTS5 tables need triggers to stay synchronized
  - Patterns: `bm25()` returns negative scores - order ASC for relevance
  - Traps: FTS5 query syntax has special characters (", -, *, etc.) that need escaping
  - Traps: Hebrew terms should be quoted in FTS5 queries for proper matching
  - Helpful context: better-sqlite3 has synchronous API (simpler than sql.js async)

---

## Iteration 10 — US-002 Task 2: Table schema verification
- **What was done**: Verified existing table schema in database.ts matches PRD specification
- **Files affected**: None (already implemented correctly)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - SQLite table `decisions` has all 12 required columns per PRD
  - Column mapping: id, database, title, url, block, plot, committee, appraiser, case_type, decision_date, publish_date, content_hash, indexed_at
  - Snake_case used in SQL (standard convention), camelCase in TypeScript via `rowToDecision()` converter
  - Additional `pdf_text TEXT` column present for future US-003 (PDF extraction)
  - `Decision` interface in types.ts:8-22 defines all required fields
  - `DecisionRow` interface in types.ts:24-38 defines SQL row structure
  - `rowToDecision()` function in types.ts:135-151 handles conversion
- **Learnings for next cycles**:
  - Patterns: SQL columns use snake_case, TypeScript uses camelCase with converter function
  - Patterns: Schema was implemented correctly in iteration 9 as part of better-sqlite3 migration
  - Helpful context: PRD schema and database.ts schema match exactly

---

## Iteration 11 — US-002 Task 3: FTS5 virtual table indexing
- **What was done**: Verified existing FTS5 virtual table implementation indexes all required columns
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` lines 94-128)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - FTS5 virtual table `decisions_fts` created at lines 94-104
  - Indexes exactly 4 columns per PRD: `title`, `committee`, `appraiser`, `case_type`
  - Uses `unicode61` tokenizer for Hebrew text support
  - External content mode (`content='decisions'`) avoids data duplication
  - Three triggers (INSERT/DELETE/UPDATE) at lines 107-128 keep FTS5 synchronized
  - `search()` method at lines 291-410 uses FTS5 MATCH with bm25() ranking
- **Learnings for next cycles**:
  - Patterns: FTS5 was implemented in iteration 9 alongside better-sqlite3 migration
  - Patterns: Check completion criteria against existing code before starting work
  - Helpful context: PRD column names use camelCase (caseType), SQL uses snake_case (case_type)

---

## Iteration 12 — US-002 Task 4: Support filtering by any combination of fields
- **What was done**: Verified existing implementation already supports filtering by any combination of fields
- **Files affected**: None (already implemented in `mcp-server/src/database.ts` lines 291-410)
- **Validation**: TypeScript type check passes (`npx tsc --noEmit` succeeds)
- **Implementation details**:
  - `search()` method uses `conditions.push()` pattern to build AND-joined WHERE clause
  - Supported filters that combine freely:
    - `database` (exact match, line 300-303)
    - `committee` (LIKE partial match, line 306-309)
    - `block` (exact match, line 312-315)
    - `plot` (exact match, line 316-319)
    - `appraiser` (LIKE partial match, line 322-325)
    - `caseType` (LIKE partial match, line 328-331)
    - `fromDate`/`toDate` (date range, lines 334-341)
    - `query` (FTS5 full-text search, lines 344-348)
  - All filters work together via: `WHERE ${conditions.join(' AND ')}` (lines 363, 386)
  - `SearchParams` interface in types.ts:41-54 defines all filter fields
- **Learnings for next cycles**:
  - Patterns: The `1=1` base condition (line 294) simplifies dynamic AND clause building
  - Patterns: LIKE with `%value%` provides partial Hebrew name matching
  - Patterns: Exact match for block/plot since these are numeric identifiers
  - Helpful context: Implementation was done in iteration 9 as part of better-sqlite3 migration
